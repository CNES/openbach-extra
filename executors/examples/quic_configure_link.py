#!/usr/bin/env python

# OpenBACH is a generic testbed able to control/configure multiple
# network/physical entities (under test) and collect data from them.
# It is composed of an Auditorium (HMIs), a Controller, a Collector
# and multiple Agents (one for each network entity that wants to be
# tested).
#
#
# Copyright © 2016-2020 CNES
#
#
# This file is part of the OpenBACH testbed.
#
#
# OpenBACH is a free software : you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY, without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see http://www.gnu.org/licenses/.

"""Example of scenarios composition.

Data is transmitted from a server to a client
The test reports
 - The evolution of the received bit_rate
 - The evolution of the sent bit_rate
 - The evolution of the sent data
 - The time needed to receive the file

+-----------+     +-----------------------+     +-----------+
| data      |<--->| delay/bandwidth       |<--->| data      |
| server    |     | limitation            |     | client    |
+-----------+     +-----------------------+     +-----------+
|  server_ip|     |                       |     |client_ip  |
|           |     |              midbox_if|     |           |
+-----------+     +-----------------------+     +-----------+
| entity:   |     | entity:               |     | entity:   |
|  server   |     |  midbox (middle-box)  |     |  client   |
+-----------+     +-----------------------+     +-----------+

OpenBACH parameters:
 - entity_pp : entity where the post-processing will be performed
 - project_name : the name of the project
 - path : the path where the post processing data will be stored

Specific scenario parameters:
 - file_size : the size of the file to transmit
 - bandwidth_server_to_client : the bandwidth limitation in the
     server to client direction
 - bandwidth_client_to_server : the bandwidth limitation in the
     client to server direction
 - delay_server_to_client : the delay limitation in the
     server to client direction
 - delay_client_to_server : the delay limitation in the
     client to server direction

Other parameters:
 - server_ip : ip address of the server
 - client_ip : ip address of the client
 - midbox_if: Interface name on which the delay and/or bandwidth
     limitation is introduced

Step-by-step description of the scenario:
 - clean-midbox-if : clean the middle box interface
 - add-limit-if : add delay and/or bandwidth limitations in both
     directions on midbox-if                                      
 - qos-eval : run QoS evaluation in both direction
 - download : start the download of file_size
 - clean-midbox-if : clean the middle box interface
"""


from auditorium_scripts.scenario_observer import ScenarioObserver, DataProcessor
from scenario_builder.scenarios import network_configure_link, service_quic
from scenario_builder.helpers.service.quic import quic_find_client


def extract_quic_statistic(job):
    """Extract the `download_time` stat from the statistics generated by
    an quic job.

    """
    #data = job.statistics_data[('Flow1',)].dated_data
    #data = job.statistics_data.dated_data
    data = job.statistics.dated_data
    return [
            (timestamp, stats['download_time'])
            for timestamp, stats in data.items()
    ]


def main(argv=None):
    observer = ScenarioObserver()
    observer.add_scenario_argument(
            '--entity', '--configure-link-entity', '-e', required=True,
            help='Name of the entity where configure link should run')
    observer.add_scenario_argument(
            '--bandwidth-server-to-client', '-B', required=True,
            help='Bandwidth allocated for the server to answer the client')
    observer.add_scenario_argument(
            '--bandwidth-client-to-server', '-b', required=True,
            help='Bandwidth allocated for the client to ask the server')
    observer.add_scenario_argument(
            '--delay-server-to-client', '-D', required=True, type=int,
            help='Delay for a packet to go from the server to the client')
    observer.add_scenario_argument(
            '--delay-client-to-server', '-d', required=True, type=int,
            help='Delay for a packet to go from the client to the server')
    observer.add_scenario_argument(
            '--middlebox-interfaces', '--interfaces', '-m', required=True,
            help='Comma-separated list of the network interfaces to emulate link on on the middlebox')

    observer.add_scenario_argument(
            '--server', '-s', required=True,
            help='name of the entity on which to run QUIC server')
    observer.add_scenario_argument(
            '--server-ip', '-A', required=True,
            help='The IP address of the QUIC server')
    observer.add_scenario_argument(
            '--server-port', '-P', default=4433,
            help='The port of the server to connect to/listen on')
    observer.add_scenario_argument(
            '--server-implementation', '-I', required=True,
            help='The QUIC implementation to run by the server. Possible values are: ngtcp2, picoquic, quicly')
    observer.add_scenario_argument(
            '--client', '-c', required=True,
            help='name of the entity on which to run QUIC client')
    observer.add_scenario_argument(
            '--client-implementation', '-i', required=True,
            help='The QUIC implementation to run by the client. Possible values are: ngtcp2, picoquic, quicly')
    observer.add_scenario_argument(
            '--resources', '-r', required=True,
            help='Comma-separed list of resources to download in parallel over concurrent streams')
    observer.add_scenario_argument(
            '--download-dir', '-w',
            help='The path to the directory to save downloaded resources')
    observer.add_scenario_argument(
            '--server-log-dir', '-L',
            help='The path to the directory to save server\'s logs')
    observer.add_scenario_argument(
            '--server-extra-args', '-X',
            help='Specify additional CLI arguments that are supported by the chosen server implementation')

    observer.add_scenario_argument(
            '--client-log-dir', '-l',
            help='The path to the directory to save client\'s logs')
    observer.add_scenario_argument(
            '--client-extra-args', '-x',
            help='Specify additional CLI arguments that are supported by the chosen client implementation')
    observer.add_scenario_argument(
            '--nb-runs', '-N', default=1,
            help='The number of times resources will be downloaded')

    observer.add_scenario_argument(
            '--post-processing-entity', 
            help='The entity where the post-processing will be performed '
                 '(histogram/time-series jobs must be installed) if defined')
    args = observer.parse(argv)

    # Setup link constraints using prebuilt scenarios
    print('Clearing interfaces')
    scenario = network_configure_link.build(
            args.entity,
            args.middlebox_interfaces,
            'ingress',
            'clear',
            args.bandwidth_server_to_client,
            args.delay_server_to_client)
    observer.launch_and_wait(scenario)

    scenario = network_configure_link.build(
            args.entity,
            args.middlebox_interfaces,
            'egress',
            'clear',
            args.bandwidth_client_to_server,
            args.delay_client_to_server)
    observer.launch_and_wait(scenario)

    print('Setting interfaces')
    scenario = network_configure_link.build(
            args.entity,
            args.middlebox_interfaces,
            'ingress',
            'apply',
            args.bandwidth_server_to_client,
            args.delay_server_to_client)
    observer.launch_and_wait(scenario)

    scenario = network_configure_link.build(
            args.entity,
            args.middlebox_interfaces,
            'egress',
            'apply',
            args.bandwidth_client_to_server,
            args.delay_client_to_server)
    observer.launch_and_wait(scenario)

    # Test download resources  using prebuilt scenario
    print('Download', args.resources)
    scenario = service_quic.build(
            args.server,
            args.server_ip,
            args.server_port,
            args.server_implementation,
            args.client,
            args.client_implementation,
            args.resources,
            args.nb_runs,
            args.download_dir,
            args.server_log_dir,
            args.server_extra_args,
            args.client_log_dir,
            args.client_extra_args,
            args.post_processing_entity)
    observer.launch_and_wait(scenario)

    # Post process the result of the last scenario
    results = DataProcessor(observer)
    # Here we are only interested into the data from the quic client job
    # Since we know the `service_quic` only launch one such job, we can
    # easily get its ID path (including subscenario instance IDs)
    quic_client, = scenario.extract_function_id(quic=quic_find_client, include_subscenarios=True)
    # Tell the post processor how we want to extract the data from our job and
    # under which key we want to get those data back. We do it once here but we
    # can register as many callback as necessary, they will run on the same data
    # once it has been fetched.
    print(quic_client)
    results.add_callback('download', extract_quic_statistic, quic_client)
    # Actually fetches raw data and run them through each registered callbacks
    data = results.post_processing()
    # From here on, we can do anything with our massaged data. This example
    # offers a simple `print`, but `matplotlib.pyplot` is most likely what
    # you’ll be after
    print('Results from downloaded resources:', data['download'])

    # Cleanup after ourselves using prebuilt scenario
    print('Clearing interfaces')
    scenario = network_configure_link.build(
            args.entity,
            args.middlebox_interfaces,
            'ingress',
            'clear',
            args.bandwidth_server_to_client,
            args.delay_server_to_client)
    observer.launch_and_wait(scenario)

    scenario = network_configure_link.build(
            args.entity,
            args.middlebox_interfaces,
            'egress',
            'clear',
            args.bandwidth_client_to_server,
            args.delay_client_to_server)
    observer.launch_and_wait(scenario)


if __name__ == '__main__':
    main()
