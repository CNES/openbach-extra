#!/usr/bin/env python3
# -*- coding: utf-8 -*-

#  OpenBACH is a generic testbed able to control/configure multiple
#  network/physical entities (under test) and collect data from them. It is
#  composed of an Auditorium (HMIs), a Controller, a Collector and multiple
#  Agents (one for each network entity that wants to be tested).
#
#
#  Copyright Â© 2020 CNES
#
#
#  This file is part of the OpenBACH testbed.
#
#
#  OpenBACH is a free software : you can redistribute it and/or modify it under
#  the terms of the GNU General Public License as published by the Free
#  Software Foundation, either version 3 of the License, or (at your option)
#  any later version.
#
#  This program is distributed in the hope that it will be useful, but WITHOUT
#  ANY WARRANTY, without even the implied warranty of MERCHANTABILITY or
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
#  more details. # # You should have received a copy of the GNU General Public License along with
#  this program. If not, see http://www.gnu.org/licenses/.


"""Sources of the Job d-itg_send"""


__author__ = 'CNES'
__credits__ = '''Contributor: Guillaume Colombo <guillaume.colombo@cnes.fr>
              Matthieu Petrou <matthieu.petrou@viveris.fr>
              '''

import argparse
import subprocess
import time
import os
import collect_agent
conffile = "/opt/openbach/agent/jobs/d-itg_send/d-itg_send_rstats_filter.conf"


def main(target_address, log_address, dest_path, granularity, traffic_type = 'UDP', port = 8999, signal_port = 9000,
         packet_size = 512, packet_rate = 1000, bandwidth = '0', duration = 10, data_size = '0', meter = 'rttm'):

    # Clean previous log and set up the D-ITG LogServer*
    if os.path.isfile('/tmp/ITGRecv.log'):
        os.system('rm /tmp/ITGRecv.log')
    if os.path.isfile('/tmp/ITGSend.log'):
        os.system('rm /tmp/ITGSend.log')

    proc_log = subprocess.Popen('/opt/openbach/agent/jobs/d-itg_send/d-itg/bin/ITGLog', shell=False)

    # Get the reference time for changing the stats generated by D-ITG
    time_ref = int(round(time.time() * 1000))

    #Set packet_rate depending on bandwidth parameter
    if bandwidth != '0':
        if 'K' == 'K' in bandwidth:
            packet_rate = 1000 * int(bandwidth.replace('K',''))
        elif 'M' == 'M' in bandwidth:
            packet_rate = 1000 * 1000 * int(bandwidth.replace('M',''))
        elif 'G' == 'G' in bandwidth:
            packet_rate = 1000 * 1000 * 1000 * int(bandwidth.replace('G',''))
        else:
            packet_rate = int(bandwidth)
        packet_rate = packet_rate/(8 * packet_size)

    # Build and launch the D-ITGSend command
    cmd_send = '/opt/openbach/agent/jobs/d-itg_send/d-itg/bin/ITGSend -a {} -L {} -X {} '.format(target_address, log_address, log_address)
    cmd_send +='-T {} -c {} -C {} -t {} -m {} '.format(traffic_type, packet_size, packet_rate, duration * 1000, meter)
    cmd_send +='-Sdp {} -Ssp {} -rp {}  '.format(signal_port, signal_port, port)
   
    #Set number of KBytes to generate
    if data_size != '0':
        if 'M' == 'M' in data_size:
            data_size_f = 1024 * float(data_size.replace('M',''))
        elif 'G' == 'G' in data_size:
            data_size_f = 1024 * 1024 * float(data_size.replace('G',''))
        else:
            data_size_f = float(data_size.replace('K',''))
        cmd_send +='-k {}'.format(data_size_f)

    subprocess.call(cmd_send, shell=True)

    # Terminate the process of the D-ITG LogServer
    proc_log.terminate()

    # Clear potential old stats
    if os.path.isfile('{}/RCV'.format(dest_path)):
        os.system('rm {}/RCV'.format(dest_path))
    if os.path.isfile('{}/SND'.format(dest_path)):
        os.system('rm {}/SND'.format(dest_path))

    # Get the stats from the logs
    cmd_rcv_cb = '/opt/openbach/agent/jobs/d-itg_send/d-itg/bin/ITGDec /tmp/ITGRecv.log -c {} {}/RCV'.format(granularity, dest_path)
    subprocess.call(cmd_rcv_cb, shell=True)
    cmd_snd_cb = '/opt/openbach/agent/jobs/d-itg_send/d-itg/bin/ITGDec /tmp/ITGSend.log -c {} {}/SND'.format(granularity, dest_path)
    subprocess.call(cmd_snd_cb, shell=True)

    # Check the connection with the collector
    success = collect_agent.register_collect(conffile)
    if not success:
        return

    # Send the stats of the receiver to the collector
    path_RCV = '{}/RCV'.format(dest_path)
    stats = open(path_RCV, "r")
    
    owd_r = []
    for line in stats:
        txt = line.strip()
        txt = txt.split(' ')

        # Get the timestamp (in ms)
        timestamp = txt[0].replace('.','')
        timestamp = int(timestamp[:-3])
        timestamp = timestamp + time_ref

        # Get the bitrate (in bps)
        bitrate = txt[1]
        bitrate = float(bitrate)*1024
        statistics = {'bitrate_receiver': bitrate}
        collect_agent.send_stat(timestamp, **statistics)

        # Get the delay (in ms)
        delay = txt[2]
        delay = float(delay)*1000
        owd_r.append(delay)
        statistics = {'owd_receiver': delay}
        collect_agent.send_stat(timestamp, **statistics)

        # Get the jitter (in ms)
        jitter = txt[3]
        jitter = float(jitter)*1000
        statistics = {'jitter_receiver': jitter}
        collect_agent.send_stat(timestamp, **statistics)

        # Get the packetloss
        pck_loss = txt[4]
        pck_loss = float(pck_loss)
        statistics = {'packetloss_receiver': pck_loss}
        collect_agent.send_stat(timestamp, **statistics)

    stats.close()

    # Send the stats of the sender to the collector
    path_SND = '{}/SND'.format(dest_path)
    stats = open(path_SND, "r")

    owd_s = []
    timetab = []
    for line in stats:
        txt = line.strip()
        txt = txt.split(' ')

        # Get the timestamp (in ms)
        timestamp = txt[0].replace('.','')
        timestamp = int(timestamp[:-3])
        timestamp = timestamp + time_ref

        # Get the bitrate (in bps)
        bitrate = txt[1]
        bitrate = float(bitrate)*1024
        statistics = {'bitrate_sender': bitrate}
        collect_agent.send_stat(timestamp, **statistics)

        if meter == "rttm" or meter == "RTTM":
            # Get the delay (in ms)
            delay = txt[2]
            delay = float(delay)*1000
            owd_s.append(delay)
            timetab.append(timestamp)
            statistics = {'rtt_sender': delay}
            collect_agent.send_stat(timestamp, **statistics)

            # Get the jitter (in ms)
            jitter = txt[3]
            jitter = float(jitter)*1000
            statistics = {'jitter_sender': jitter}
            collect_agent.send_stat(timestamp, **statistics)

            # Get the packetloss
            pck_loss = txt[4]
            pck_loss = float(pck_loss)
            statistics = {'packetloss_sender': pck_loss}
            collect_agent.send_stat(timestamp, **statistics)        

    stats.close()
    if meter == "rttm" or meter == "RTTM":
       for n in range(0, len(owd_s)):
          owd_return = owd_s[n] - owd_r[n]
          statistics = {'owd_return': owd_return}
          collect_agent.send_stat(timetab[n], **statistics)
    
if __name__ == "__main__":
    # Define Usage
    parser = argparse.ArgumentParser(description='Create a D-ITG command',
                                     formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    parser.add_argument('target_address', type=str, metavar='Target_address',
                        help='Address IP where the flow is sent')
    parser.add_argument('sender_address', type=str,  metavar='sender_address',
                        help="Address of the sender to get the receiver's logs")
    parser.add_argument('dest_path', type=str, metavar='Destination_path',
                        help='Path where the stats will be located')
    parser.add_argument('granularity', type=int, metavar='Granularity',
                        help='Set the granularity (in ms) at which the stats will be generated')
    parser.add_argument('-T', '--traffic_type', type=str, metavar='TRAFFIC TYPE', default = 'UDP', 
                        help='Traffic type (UDP, TCP, ICMP, ...) (default=UDP)')
    parser.add_argument('-p', '--port', type=int, metavar='PORT', default = 8999,
                        help='Set server port (default=8999)')
    parser.add_argument('-P', '--signal_port', type=int, metavar='SIGNAL PORT', default = 9000,
                        help='Set port for signal transmission (default=9000)')
    parser.add_argument('-c', '--packet_size', type=int, metavar='PACKET SIZE',
                        help='Size of each packet in byte default=512', default = 512)
    parser.add_argument('-C', '--packet_rate', type=int, metavar='PACKET RATE', default = 1000,
                        help='Number of packets to send in one second (default=1000)')
    parser.add_argument('-B', '--bandwidth', type=str, metavar='BANDWIDTH',
                        help='Set bandwidth in [K/M/G]bits/s, if set will overrun packet_rate (default=0)', default = '0')
    parser.add_argument('-d', '--duration', type=int, metavar='DURATION',
                        help='Duration of the traffic in s (default=10)', default = 10)
    parser.add_argument('-k', '--data_size', type=str, metavar='DATA SIZE', default = '0',
                        help='Set the number of [K/M/G]Bytes to send, if set either duration or data_size will limit the job')
    parser.add_argument('-m', '--meter', type=str, metavar='METER', choices=['owdm', 'rttm'], 
                        help='Way to compute the time: One Way Delay (owdm) or Round Trip Time (rttm) (default=rttm)',
                        default = 'rttm')

    # get args
    args = parser.parse_args()
    target_address = args.target_address
    sender_address = args.sender_address
    dest_path = args.dest_path
    granularity = args.granularity
    traffic_type = args.traffic_type
    port = args.port
    signal_port = args.signal_port
    packet_size = args.packet_size
    packet_rate = args.packet_rate
    bandwidth = args.bandwidth
    duration = args.duration
    data_size = args.data_size
    meter = args.meter
   
    main(target_address, sender_address, dest_path, granularity, traffic_type, port, signal_port, packet_size, packet_rate, bandwidth, duration, data_size, meter)

