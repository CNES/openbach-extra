#!/usr/bin/env python3
# -*- coding: utf-8 -*-

#  OpenBACH is a generic testbed able to control/configure multiple
#  network/physical entities (under test) and collect data from them. It is
#  composed of an Auditorium (HMIs), a Controller, a Collector and multiple
#  Agents (one for each network entity that wants to be tested).
#
#
#  Copyright Â© 2020 CNES
#
#
#  This file is part of the OpenBACH testbed.
#
#
#  OpenBACH is a free software : you can redistribute it and/or modify it under
#  the terms of the GNU General Public License as published by the Free
#  Software Foundation, either version 3 of the License, or (at your option)
#  any later version.
#
#  This program is distributed in the hope that it will be useful, but WITHOUT
#  ANY WARRANTY, without even the implied warranty of MERCHANTABILITY or
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
#  more details. # # You should have received a copy of the GNU General Public License along with
#  this program. If not, see http://www.gnu.org/licenses/.


"""Sources of the Job d-itg_send"""


__author__ = 'CNES'
__credits__ = '''Contributor: Guillaume Colombo <guillaume.colombo@cnes.fr>'''

import argparse
import subprocess
import time
import collect_agent
conffile = "/opt/openbach-jobs/d-itg_send/d-itg_send_rstats_filter.conf"


def main(target_address, log_address, dest_path, granularity, traffic_type, packet_size, packet_rate, duration, meter):

    # Set up the D-ITG LogServer
    proc_log = subprocess.Popen('/opt/openbach-jobs/d-itg_send/d-itg/bin/ITGLog', shell=False)

    # Get the reference time for changing the stats generated by D-ITG
    time_ref = int(round(time.time() * 1000))

    # Build and launch the D-ITGSend command
    cmd_send = '/opt/openbach-jobs/d-itg_send/d-itg/bin/ITGSend -a {} -L {} -X {} '.format(target_address, log_address, log_address)

    if traffic_type:
        cmd_send = '{} -T {}'.format(cmd_send, traffic_type)
    if packet_size:
        cmd_send = '{} -c {}'.format(cmd_send, packet_size)
    if packet_rate:
        cmd_send = '{} -C {}'.format(cmd_send, packet_rate)
    if duration:
        cmd_send = '{} -t {}'.format(cmd_send, duration)
    if meter:
        cmd_send = '{} -m {}'.format(cmd_send, meter)

    subprocess.call(cmd_send, shell=True)

    # Terminate the process of the D-ITG LogServer
    proc_log.terminate()

    # Get the stats from the logs
    cmd_rcv_cb = '/opt/openbach-jobs/d-itg_send/d-itg/bin/ITGDec /tmp/ITGRecv.log -c {} {}/RCV'.format(granularity, dest_path)
    subprocess.call(cmd_rcv_cb, shell=True)
    cmd_snd_cb = '/opt/openbach-jobs/d-itg_send/d-itg/bin/ITGDec /tmp/ITGSend.log -c {} {}/SND'.format(granularity, dest_path)
    subprocess.call(cmd_snd_cb, shell=True)

    # Check the connection with the collector
    success = collect_agent.register_collect(conffile)
    if not success:
        return

    # Send the stats of the receiver to the collector
    path_RCV = '{}/RCV'.format(dest_path)
    stats = open(path_RCV, "r")

    for line in stats:
        txt = line.strip()
        txt = txt.split(' ')

        # Get the timestamp (in ms)
        timestamp = txt[0].replace('.','')
        timestamp = int(timestamp[:-3])
        timestamp = timestamp + time_ref

        # Get the bitrate (in bps)
        bitrate = txt[1]
        bitrate = float(bitrate)*1024
        statistics = {'bitrate receiver (bits/sec)': bitrate}
        collect_agent.send_stat(timestamp, **statistics)

        # Get the delay (in ms)
        delay = txt[2]
        delay = float(delay)*1000
        statistics = {'owd receiver (ms)': delay}
        collect_agent.send_stat(timestamp, **statistics)

        # Get the jitter (in ms)
        jitter = txt[3]
        jitter = float(jitter)*1000
        statistics = {'jitter receiver (ms)': jitter}
        collect_agent.send_stat(timestamp, **statistics)

        # Get the packetloss
        pck_loss = txt[4]
        pck_loss = float(pck_loss)
        statistics = {'packetloss receiver': pck_loss}
        collect_agent.send_stat(timestamp, **statistics)

    stats.close()

    # Send the stats of the sender to the collector
    path_SND = '{}/SND'.format(dest_path)
    stats = open(path_SND, "r")

    for line in stats:
        txt = line.strip()
        txt = txt.split(' ')

        # Get the timestamp (in ms)
        timestamp = txt[0].replace('.','')
        timestamp = int(timestamp[:-3])
        timestamp = timestamp + time_ref

        # Get the bitrate (in bps)
        bitrate = txt[1]
        bitrate = float(bitrate)*1024
        statistics = {'bitrate sender (bits/sec)': bitrate}
        collect_agent.send_stat(timestamp, **statistics)

        if meter == "rttm" or meter == "RTTM":
            # Get the delay (in ms)
            delay = txt[2]
            delay = float(delay)*1000
            statistics = {'rtt sender (ms)': delay}
            collect_agent.send_stat(timestamp, **statistics)

            # Get the jitter (in ms)
            jitter = txt[3]
            jitter = float(jitter)*1000
            statistics = {'jitter sender (ms)': jitter}
            collect_agent.send_stat(timestamp, **statistics)

            # Get the packetloss
            pck_loss = txt[4]
            pck_loss = float(pck_loss)
            statistics = {'packetloss sender': pck_loss}
            collect_agent.send_stat(timestamp, **statistics)        

    stats.close()
   
    
if __name__ == "__main__":
    # Define Usage
    parser = argparse.ArgumentParser(description='Create a D-ITG command',
                                     formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    parser.add_argument('target_address', type=str, metavar='Target_address',
                        help='Address IP where the flow is sent')
    parser.add_argument('sender_address', type=str,  metavar='sender_address',
                        help="Address of the sender to get the receiver's logs")
    parser.add_argument('dest_path', type=str, metavar='Destination_path',
                        help='Path where the stats will be located')
    parser.add_argument('granularity', type=int, metavar='Granularity',
                        help='Set the granularity (in ms) at which the stats will be generated')
    parser.add_argument('-T', '--traffic_type', type=str, metavar='TRAFFIC TYPE',
                        help='Traffic type (UDP, TCP, ICMP, ...) (default=UDP)')
    parser.add_argument('-c', '--packet_size', type=int, metavar='PACKET SIZE',
                        help='Size of each packet in byte default=512')
    parser.add_argument('-C', '--packet_rate', type=int, metavar='PACKET RATE',
                        help='Number of packets to send in one second (default=1000)')
    parser.add_argument('-t', '--duration', type=int, metavar='DURATION',
                        help='Duration of the traffic in ms (default=10000)')
    parser.add_argument('-m', '--meter', type=str, metavar='METER', choices=['owdm', 'rttm'], 
                        help='Way to compute the time: One Way Delay (owdm) or Round Trip Time (rttm) (default=rttm)',
                        default = 'rttm')

    # get args
    args = parser.parse_args()
    target_address = args.target_address
    sender_address = args.sender_address
    dest_path = args.dest_path
    granularity = args.granularity
    traffic_type = args.traffic_type
    packet_size = args.packet_size
    packet_rate = args.packet_rate
    duration = args.duration
    meter = args.meter
    
    main(target_address, sender_address, dest_path, granularity, traffic_type, packet_size, packet_rate, duration, meter)

